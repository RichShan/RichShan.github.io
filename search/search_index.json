{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Richard Shan","title":"Home"},{"location":"#richard-shan","text":"","title":"Richard Shan"},{"location":"about/","text":"About Me","title":"About"},{"location":"about/#about-me","text":"","title":"About Me"},{"location":"coding/","text":"Here are some of my coding projects: Macro Maker","title":"Coding"},{"location":"coding/#here-are-some-of-my-coding-projects","text":"","title":"Here are some of my coding projects:"},{"location":"coding/#macro-maker","text":"","title":"Macro Maker"},{"location":"fab/","text":"Fab Academy Prefab Storage Box Arcade Glasses Gyroscope Spinner Pen Turning RP2040 Setup","title":"Fab Academy"},{"location":"fab/#fab-academy","text":"","title":"Fab Academy"},{"location":"fab/#prefab","text":"","title":"Prefab"},{"location":"fab/#storage-box","text":"","title":"Storage Box "},{"location":"fab/#arcade","text":"","title":"Arcade "},{"location":"fab/#glasses","text":"","title":"Glasses "},{"location":"fab/#gyroscope-spinner","text":"","title":"Gyroscope Spinner "},{"location":"fab/#pen-turning","text":"","title":"Pen Turning "},{"location":"fab/#rp2040-setup","text":"","title":"RP2040 Setup "},{"location":"coding/macro/","text":"Macro Maker Description The Macro project was my final project for Java Data Structures (H) in 10th grade, of which the requirements can be found here . The final product allows the user to start and end a global recording of all inputs to the computer. The global recording will inputs including mouse movements; mouse dragging; mouse clicking, releasing, and holding; key presses, releases, and hold times; and any simultaneous combination of events. The actions are also logged in the logger.out file. After the user begins recording, (CTRL + SHIFT+ R), all henceforth input actions are recorded until the user stops recording (CTRL + SHIFT + S). Upon replaying, the program will execute the actions exactly as recorded. The press() methods also delays the action's execution as to match the delays between actions of the original recording. The program does not interfere with input actions or other applications in any way. Inspiration I've done a lot of scripting before, both static and dynamic through OCR. My goal with this project was to make a program that could record your actions and replay them with no need for hard coding or manual key press/mouse coordinate tracking. In the future, I plan to make make the project's logging function more useful, where the logging of actions into a seperate .txt document can function as a saved user macro sequence. Eventually I want to add a feature where the program is able to ingest a log file and replay the actions stored there, allowing users to save a specific macro multiple times past the closure of the JFrame. Method The main library that enabled the creation of this project is JNativeHook , which allows the global tracking of all actions that are sent into a computer, as opposed to only being able to detect inputs inside a specific window. In this project, JNativeHook's GlobalScreen and adapters were used, but I have overriden the action listeners and adapters with my own code to suit the needs of this project, specifically storage and replaying of inputs. When the program is running and recording is true (the user has started recording), every input action triggers a specific handler method which is able to encapsulate the event as an object to store in the recordedActions stack. During recording, a global variable of time is used to keep track of delays between actions. Every time a new action is recorded, the variable is then updated to the time in milliseconds when the action was performed. When the next action is then recorded, subtracting the last recorded time from the current system time gives us the delay, which is stored as part of the action object. Then, the time variable is updated. Thus, we are able to track the delays between actions in order to replay them at the right times. The different action classes (ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove) allow the program to store every input as an individual object. All these classes implement the Action interface, giving them all a press() method which is called when replaying. Here is an example of the handler method creating a new object: @Override public void nativeKeyPressed(NativeKeyEvent e) { // This method is called when a key is pressed; other methods handle other events. recordedActions.add(new KeyPress(e, Math.abs(System.currentTimeMillis()-time))); // Creates a new KeyPress object in the stack, parsing in the NativeKeyEvent generated by JNativeHook/GlobalScreen and the time since last recorded action time = System.currentTimeMillis(); // Updates variable time } // For context, the constructor for KeyPress is: public KeyPress(NativeKeyEvent ke, long delay) {...} The other adapter and conversion classes (SwingKeyAdapter, MouseCoordinateConverter, KeyLocationLookup, KeyCursorLookup) allow for conversion between different keycodes and screen sizes. The SwingKeyAdapter, KeyLocationLookup, and KeyCursorLookup classes convert VC keycodes used by NativeKeyEvent into VK keycodes used by KeyEvent. The MouseCoordinateConverter class allows for conversion between physical mouse cursor coordinate positions and scaled mouse cursor coordinate positions, allowing MouseMove to move the cursor to the correct point for all screen sizes on different computers. For example, the KeyPress class uses SwingKeyAdapter to translate a NativeKeyEvent keycode integer value to a KeyEvent keycode, which is what the robot from java.awt.Robot can interpret and use. @Override public void press() { robot.delay((int) delay); // Waits the millisecond amount as parsed from the constructor robot.keyPress(ska.getJavaKeyEvent(e).getKeyCode()); // Uses SwingKeyAdapter to convert keycode values } During recording, all input actions are created as new objects of their respective class and are stored in a stack until the user stops. Upon replaying the stored actions, the program will iterate through the stack and call each object's press() method to execute the action exactly as performed. for(Action i : recordedActions) { i.press(); /* The implementation of the Action inferface by all the input action classes allows me to call a generic .press() function */ } For more information, the full project can be found open-sourced on the Github repo and the downloadable jar file is not obfuscated and is decompilable. Download The github repo can be found here . The jar executable can be downloaded here . Instructions for Use Start Recording Keystrokes: CTRL + SHIFT + R Stop Recording Keystrokes and Save: CTRL + SHIFT + S Replay Saved Keystroke Sequence: CTRL + SHIFT + 1 Initial Planning Chart Key Elements Action interface implemented by all the action/event classes: ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove, etc. Every action class follows the command archetype, allowing the encapsulation of a request as an object. KeyLocationLookup Singleton - single instance of the lookup object that is referenced every time a key conversion is needed Hashtable inside KeyLocationLookup to store NativeKeyEvent KeyLocations and corresponding KeyEvent integer values for conversion Mouse and Keyboard Adapters to listen for actions within the global screen. Those adapters also function as observers for the GlobalScreen. Stack to store the recorded actions Custom MouseCoordinatesConverter component that will convert true x,y mouse coordinates to relative x, y mouse coordinates scaled to each computer's unique screen size. Also functions as an adapter. State machine under GUILogger handling action transitions and entries when a key/mouse is pressed TreeMap under KeyCursorLookup to store NativeKeyEvent VC values and corresponding KeyEvent VK values","title":"Macro Maker"},{"location":"coding/macro/#macro-maker","text":"","title":"Macro Maker"},{"location":"coding/macro/#description","text":"The Macro project was my final project for Java Data Structures (H) in 10th grade, of which the requirements can be found here . The final product allows the user to start and end a global recording of all inputs to the computer. The global recording will inputs including mouse movements; mouse dragging; mouse clicking, releasing, and holding; key presses, releases, and hold times; and any simultaneous combination of events. The actions are also logged in the logger.out file. After the user begins recording, (CTRL + SHIFT+ R), all henceforth input actions are recorded until the user stops recording (CTRL + SHIFT + S). Upon replaying, the program will execute the actions exactly as recorded. The press() methods also delays the action's execution as to match the delays between actions of the original recording. The program does not interfere with input actions or other applications in any way.","title":"Description"},{"location":"coding/macro/#inspiration","text":"I've done a lot of scripting before, both static and dynamic through OCR. My goal with this project was to make a program that could record your actions and replay them with no need for hard coding or manual key press/mouse coordinate tracking. In the future, I plan to make make the project's logging function more useful, where the logging of actions into a seperate .txt document can function as a saved user macro sequence. Eventually I want to add a feature where the program is able to ingest a log file and replay the actions stored there, allowing users to save a specific macro multiple times past the closure of the JFrame.","title":"Inspiration"},{"location":"coding/macro/#method","text":"The main library that enabled the creation of this project is JNativeHook , which allows the global tracking of all actions that are sent into a computer, as opposed to only being able to detect inputs inside a specific window. In this project, JNativeHook's GlobalScreen and adapters were used, but I have overriden the action listeners and adapters with my own code to suit the needs of this project, specifically storage and replaying of inputs. When the program is running and recording is true (the user has started recording), every input action triggers a specific handler method which is able to encapsulate the event as an object to store in the recordedActions stack. During recording, a global variable of time is used to keep track of delays between actions. Every time a new action is recorded, the variable is then updated to the time in milliseconds when the action was performed. When the next action is then recorded, subtracting the last recorded time from the current system time gives us the delay, which is stored as part of the action object. Then, the time variable is updated. Thus, we are able to track the delays between actions in order to replay them at the right times. The different action classes (ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove) allow the program to store every input as an individual object. All these classes implement the Action interface, giving them all a press() method which is called when replaying. Here is an example of the handler method creating a new object: @Override public void nativeKeyPressed(NativeKeyEvent e) { // This method is called when a key is pressed; other methods handle other events. recordedActions.add(new KeyPress(e, Math.abs(System.currentTimeMillis()-time))); // Creates a new KeyPress object in the stack, parsing in the NativeKeyEvent generated by JNativeHook/GlobalScreen and the time since last recorded action time = System.currentTimeMillis(); // Updates variable time } // For context, the constructor for KeyPress is: public KeyPress(NativeKeyEvent ke, long delay) {...} The other adapter and conversion classes (SwingKeyAdapter, MouseCoordinateConverter, KeyLocationLookup, KeyCursorLookup) allow for conversion between different keycodes and screen sizes. The SwingKeyAdapter, KeyLocationLookup, and KeyCursorLookup classes convert VC keycodes used by NativeKeyEvent into VK keycodes used by KeyEvent. The MouseCoordinateConverter class allows for conversion between physical mouse cursor coordinate positions and scaled mouse cursor coordinate positions, allowing MouseMove to move the cursor to the correct point for all screen sizes on different computers. For example, the KeyPress class uses SwingKeyAdapter to translate a NativeKeyEvent keycode integer value to a KeyEvent keycode, which is what the robot from java.awt.Robot can interpret and use. @Override public void press() { robot.delay((int) delay); // Waits the millisecond amount as parsed from the constructor robot.keyPress(ska.getJavaKeyEvent(e).getKeyCode()); // Uses SwingKeyAdapter to convert keycode values } During recording, all input actions are created as new objects of their respective class and are stored in a stack until the user stops. Upon replaying the stored actions, the program will iterate through the stack and call each object's press() method to execute the action exactly as performed. for(Action i : recordedActions) { i.press(); /* The implementation of the Action inferface by all the input action classes allows me to call a generic .press() function */ } For more information, the full project can be found open-sourced on the Github repo and the downloadable jar file is not obfuscated and is decompilable.","title":"Method"},{"location":"coding/macro/#download","text":"","title":"Download"},{"location":"coding/macro/#the-github-repo-can-be-found-here","text":"","title":"The github repo can be found here."},{"location":"coding/macro/#the-jar-executable-can-be-downloaded-here","text":"","title":"The jar executable can be downloaded here."},{"location":"coding/macro/#instructions-for-use","text":"Start Recording Keystrokes: CTRL + SHIFT + R Stop Recording Keystrokes and Save: CTRL + SHIFT + S Replay Saved Keystroke Sequence: CTRL + SHIFT + 1","title":"Instructions for Use"},{"location":"coding/macro/#initial-planning-chart","text":"","title":"Initial Planning Chart"},{"location":"coding/macro/#key-elements","text":"Action interface implemented by all the action/event classes: ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove, etc. Every action class follows the command archetype, allowing the encapsulation of a request as an object. KeyLocationLookup Singleton - single instance of the lookup object that is referenced every time a key conversion is needed Hashtable inside KeyLocationLookup to store NativeKeyEvent KeyLocations and corresponding KeyEvent integer values for conversion Mouse and Keyboard Adapters to listen for actions within the global screen. Those adapters also function as observers for the GlobalScreen. Stack to store the recorded actions Custom MouseCoordinatesConverter component that will convert true x,y mouse coordinates to relative x, y mouse coordinates scaled to each computer's unique screen size. Also functions as an adapter. State machine under GUILogger handling action transitions and entries when a key/mouse is pressed TreeMap under KeyCursorLookup to store NativeKeyEvent VC values and corresponding KeyEvent VK values","title":"Key Elements"},{"location":"fab/arcade/","text":"Tiny Arcade Assembly Today, I fully built and assembled the Tiny Arcade kit. The kit consisted of a bunch of small plastic parts which would be assembled together to create a small arcade machine. The acrylic was cut pretty roughly, however, so picking the pieces apart took some time. The largest problem, by far, was that the build had structural integrity issues through much of the assembly process due to only being held together by a single screw and would fall apart whenever it was turned. I solved this problem through having someone else assist me in holding the arcade as I pushed the pieces together. After all the pieces were in, the arcade was a lot more stable. I first added the joystick and input buttons onto the board. I then attached the speaker. Here are all the acrylic pieces laid out before assembly: Next, I assembled the first side of the arcade, along with attaching the battery and the screw. I then put the second side of the arcade machine in, allowing me to fully screw both sides together. This is what the arcade looks like after assembling the rest of the acrylic pieces: Final step: stickers! Adding Games The base arcade came loaded with only 3 games on it. However, the arcade is able to support other games through a micro SD card. The instructions for doing so can be found on the TinyCircuits website here . My regular computer didn't have either an SD card or microSD port so I had to switch to a second computer. After that, I downloaded the other games from the TinyCircuits website . This is what the zip file containing all the games looks like. Within each of these game folders is a bin and a tsv file for that respective game. I then uploaded the contents of the zip file into the micro SD card, which was the D drive under my file system. After ejecting the micro SD card from the computer port, I put it into the port inside the TinyArcade machine. Instead of displaying a screen upon startup with a message notifying the user that there is no SD card inserted, the Arcade now starts up and allows the user to play all the imported games. The Arcade steps through the games in alphabetical order. All the added games are now playable!","title":"Tiny Arcade"},{"location":"fab/arcade/#tiny-arcade","text":"","title":"Tiny Arcade"},{"location":"fab/arcade/#assembly","text":"Today, I fully built and assembled the Tiny Arcade kit. The kit consisted of a bunch of small plastic parts which would be assembled together to create a small arcade machine. The acrylic was cut pretty roughly, however, so picking the pieces apart took some time. The largest problem, by far, was that the build had structural integrity issues through much of the assembly process due to only being held together by a single screw and would fall apart whenever it was turned. I solved this problem through having someone else assist me in holding the arcade as I pushed the pieces together. After all the pieces were in, the arcade was a lot more stable. I first added the joystick and input buttons onto the board. I then attached the speaker. Here are all the acrylic pieces laid out before assembly: Next, I assembled the first side of the arcade, along with attaching the battery and the screw. I then put the second side of the arcade machine in, allowing me to fully screw both sides together. This is what the arcade looks like after assembling the rest of the acrylic pieces: Final step: stickers!","title":"Assembly"},{"location":"fab/arcade/#adding-games","text":"The base arcade came loaded with only 3 games on it. However, the arcade is able to support other games through a micro SD card. The instructions for doing so can be found on the TinyCircuits website here . My regular computer didn't have either an SD card or microSD port so I had to switch to a second computer. After that, I downloaded the other games from the TinyCircuits website . This is what the zip file containing all the games looks like. Within each of these game folders is a bin and a tsv file for that respective game. I then uploaded the contents of the zip file into the micro SD card, which was the D drive under my file system. After ejecting the micro SD card from the computer port, I put it into the port inside the TinyArcade machine. Instead of displaying a screen upon startup with a message notifying the user that there is no SD card inserted, the Arcade now starts up and allows the user to play all the imported games. The Arcade steps through the games in alphabetical order. All the added games are now playable!","title":"Adding Games"},{"location":"fab/cardboardBox/","text":"Cardboard Storage Box Assembly Today, I cut and assembled a cardboard box to use for storage in the future. First, I downloaded the provided CDR file out of Google Drive. I then ran the file through the laser cutter and took out the cardboard. This is the box after the cut. I folded in all the parts of the box to ensure that they assembled nicely. Here is the box after I folded it all together and hot glued it: Stickers I first imported a design into Silhouette Studio and traced it. I then cut out the design and placed the sticker onto my box. Here is the box with the bird design and a sticker of my name:","title":"Cardboard Storage Box"},{"location":"fab/cardboardBox/#cardboard-storage-box","text":"","title":"Cardboard Storage Box"},{"location":"fab/cardboardBox/#assembly","text":"Today, I cut and assembled a cardboard box to use for storage in the future. First, I downloaded the provided CDR file out of Google Drive. I then ran the file through the laser cutter and took out the cardboard. This is the box after the cut. I folded in all the parts of the box to ensure that they assembled nicely. Here is the box after I folded it all together and hot glued it:","title":"Assembly"},{"location":"fab/cardboardBox/#stickers","text":"I first imported a design into Silhouette Studio and traced it. I then cut out the design and placed the sticker onto my box. Here is the box with the bird design and a sticker of my name:","title":"Stickers"},{"location":"fab/glasses/","text":"Flashing Glasses I built a pair of glasses that can light up and flash the LEDs based on how much sound is around them. The glasses came in a kit, of which the assembly instructions can be found here . I first soldered on the 1k, 10k, and 2M ohm resistors, respectively. I then soldered on the microphone and started on the LEDs. Here is what the glasses looked like after all the LEDs had been put in place: Next, I installed the 0.1uF 104 capacitor and LED driver. Then, I soldered on the transistor, 10uF electrolytic capacitors, and potentiometer. After adding the switch and battery holders, the board is complete. After putting the board into the plastic frame, this is what the completed glasses look like:","title":"Flashing Glasses"},{"location":"fab/glasses/#flashing-glasses","text":"I built a pair of glasses that can light up and flash the LEDs based on how much sound is around them. The glasses came in a kit, of which the assembly instructions can be found here . I first soldered on the 1k, 10k, and 2M ohm resistors, respectively. I then soldered on the microphone and started on the LEDs. Here is what the glasses looked like after all the LEDs had been put in place: Next, I installed the 0.1uF 104 capacitor and LED driver. Then, I soldered on the transistor, 10uF electrolytic capacitors, and potentiometer. After adding the switch and battery holders, the board is complete. After putting the board into the plastic frame, this is what the completed glasses look like:","title":"Flashing Glasses"},{"location":"fab/pen/","text":"Pen Turning For my first woodworking project during Fab, I turned a pen from a kit containing 2 copper tubes, an ink cartridge, and a pen tip and cap. We were each given a bit of wood which we cut into the body of the pen. We then assembled the parts together. This was also my first time turning a pen so there were a few mishaps but overall, my final product turned out well! With the help of my instructor, I first cut the wood into rectangular prisms. Next, I then used the lathe to drill a cylindrical hole inside the wood. I then sanded the copper tubes which would hold the pen cartridge in order to rough them up a bit to give it more surface area when gluing. I then glued the tubes into the previously drilled hole inside the wood. I then put the wood blocks on the lathe, pushing the rod through the copper tubes glued inside the wood. Then I used different tipped tools to chip away parts of the wood, first chipping away large chunks and eventually using a finer tipped tool to make small modifications. After cutting the wood down to a thin cylindrical shape, I used sandpaper to smooth out the surface, starting with very rough sandpaper to remove some material and flatten the surface then using finer and finer grade sandpaper to create a very smooth surface. After sanding the wood into a smooth surface, I applied a light spray of glue and accelerant as a final coating. I then used the crusher to push the pen tip, clip, and cap together with the wood body and copper cores. Here is what the pen looks like after finishing assembly:","title":"Pen Turning"},{"location":"fab/pen/#pen-turning","text":"For my first woodworking project during Fab, I turned a pen from a kit containing 2 copper tubes, an ink cartridge, and a pen tip and cap. We were each given a bit of wood which we cut into the body of the pen. We then assembled the parts together. This was also my first time turning a pen so there were a few mishaps but overall, my final product turned out well! With the help of my instructor, I first cut the wood into rectangular prisms. Next, I then used the lathe to drill a cylindrical hole inside the wood. I then sanded the copper tubes which would hold the pen cartridge in order to rough them up a bit to give it more surface area when gluing. I then glued the tubes into the previously drilled hole inside the wood. I then put the wood blocks on the lathe, pushing the rod through the copper tubes glued inside the wood. Then I used different tipped tools to chip away parts of the wood, first chipping away large chunks and eventually using a finer tipped tool to make small modifications. After cutting the wood down to a thin cylindrical shape, I used sandpaper to smooth out the surface, starting with very rough sandpaper to remove some material and flatten the surface then using finer and finer grade sandpaper to create a very smooth surface. After sanding the wood into a smooth surface, I applied a light spray of glue and accelerant as a final coating. I then used the crusher to push the pen tip, clip, and cap together with the wood body and copper cores. Here is what the pen looks like after finishing assembly:","title":"Pen Turning"},{"location":"fab/rp2040/","text":"RP2040 Soldering","title":"RP2040"},{"location":"fab/rp2040/#rp2040","text":"","title":"RP2040"},{"location":"fab/rp2040/#soldering","text":"","title":"Soldering"},{"location":"fab/spinner/","text":"Three Leaf Gyroscope Spinner Helping Hand Assembly Because this was my first time soldering after starting the Fab program, I had to build a helping hand for me to keep and use at home before I started building the three leaf gyroscope spinner. This helping hand was a lot better than the ones I had used before as it had 4 different clips that could hold an item in almost any direction. Here are all the materials: I first took all the materials out of the packaging. I then attached the alligator clips onto the legs. I put in the first two shorter legs into the base and screwed them in. After attaching the final two longer legs onto the base of the stand, the helping hand was complete. Spinner Assembly After assembling the soldering stand, I started soldering together the spinner. I built a three leaf gyroscope spinner (fidget spinner) with LEDs. The spinner uses a ball bearing to spin around the center and is able to change the patterns on the LEDs. The kit came with all the components (except the batteries) and was used as practice for surface-mount soldering. Here is the frame before any assembly: First, I soldered one of the sides on each 100 ohm resistor to align them all. After everything was aligned, I soldered on the other side of the resistors. I then soldered on the LEDs and the MCU chip. Next, I soldered on the button. I then soldered on the capacitor. Next, I soldered on the battery holders and put the batteries in it. The actual board of the spinner is now complete. Here is the spinner when I was testing the LEDs to make sure they worked before putting the framing on: After I verified that the components were working, I the ball bearing in and encased it all in the plastic frame. Here is the completed spinner as with LEDs on as it spins. The LEDs are able to light up in different sequences to form different patterns when spinning, but the camera on my phone was unable to capture the patterns becuase it wasn't very receptive to fast moving objects.","title":"Three Leaf Gyroscope Spinner"},{"location":"fab/spinner/#three-leaf-gyroscope-spinner","text":"","title":"Three Leaf Gyroscope Spinner"},{"location":"fab/spinner/#helping-hand-assembly","text":"Because this was my first time soldering after starting the Fab program, I had to build a helping hand for me to keep and use at home before I started building the three leaf gyroscope spinner. This helping hand was a lot better than the ones I had used before as it had 4 different clips that could hold an item in almost any direction. Here are all the materials: I first took all the materials out of the packaging. I then attached the alligator clips onto the legs. I put in the first two shorter legs into the base and screwed them in. After attaching the final two longer legs onto the base of the stand, the helping hand was complete.","title":"Helping Hand Assembly"},{"location":"fab/spinner/#spinner-assembly","text":"After assembling the soldering stand, I started soldering together the spinner. I built a three leaf gyroscope spinner (fidget spinner) with LEDs. The spinner uses a ball bearing to spin around the center and is able to change the patterns on the LEDs. The kit came with all the components (except the batteries) and was used as practice for surface-mount soldering. Here is the frame before any assembly: First, I soldered one of the sides on each 100 ohm resistor to align them all. After everything was aligned, I soldered on the other side of the resistors. I then soldered on the LEDs and the MCU chip. Next, I soldered on the button. I then soldered on the capacitor. Next, I soldered on the battery holders and put the batteries in it. The actual board of the spinner is now complete. Here is the spinner when I was testing the LEDs to make sure they worked before putting the framing on: After I verified that the components were working, I the ball bearing in and encased it all in the plastic frame. Here is the completed spinner as with LEDs on as it spins. The LEDs are able to light up in different sequences to form different patterns when spinning, but the camera on my phone was unable to capture the patterns becuase it wasn't very receptive to fast moving objects.","title":"Spinner Assembly"}]}