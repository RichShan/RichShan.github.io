{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Richard Shan","title":"Home"},{"location":"#richard-shan","text":"","title":"Richard Shan"},{"location":"about/","text":"About Me","title":"About"},{"location":"about/#about-me","text":"","title":"About Me"},{"location":"coding/","text":"Here are some of my coding projects: Macro Maker","title":"Coding"},{"location":"coding/#here-are-some-of-my-coding-projects","text":"","title":"Here are some of my coding projects:"},{"location":"coding/#macro-maker","text":"","title":"Macro Maker"},{"location":"edm2/","text":"Engineering 2 Deep Dive into Fusion 360 Pt. 1 Deep Dive into Fusion 360 Pt. 2","title":"Engineering 2"},{"location":"edm2/#engineering-2","text":"","title":"Engineering 2"},{"location":"edm2/#deep-dive-into-fusion-360-pt-1","text":"","title":"Deep Dive into Fusion 360 Pt. 1 "},{"location":"edm2/#deep-dive-into-fusion-360-pt-2","text":"","title":"Deep Dive into Fusion 360 Pt. 2 "},{"location":"coding/macro/","text":"Macro Maker Description The Macro project was my final project for Java Data Structures (H) in 10th grade, of which the requirements can be found here . The final product allows the user to start and end a global recording of all inputs to the computer. The global recording will inputs including mouse movements; mouse dragging; mouse clicking, releasing, and holding; key presses, releases, and hold times; and any simultaneous combination of events. The actions are also logged in the logger.out file. After the user begins recording, (CTRL + SHIFT+ R), all henceforth input actions are recorded until the user stops recording (CTRL + SHIFT + S). Upon replaying, the program will execute the actions exactly as recorded. The press() methods also delays the action's execution as to match the delays between actions of the original recording. The program does not interfere with input actions or other applications in any way. Inspiration I've done a lot of scripting before, both static and dynamic through OCR. My goal with this project was to make a program that could record your actions and replay them with no need for hard coding or manual key press/mouse coordinate tracking. In the future, I plan to make make the project's logging function more useful, where the logging of actions into a seperate .txt document can function as a saved user macro sequence. Eventually I want to add a feature where the program is able to ingest a log file and replay the actions stored there, allowing users to save a specific macro multiple times past the closure of the JFrame. Method The main library that enabled the creation of this project is JNativeHook , which allows the global tracking of all actions that are sent into a computer, as opposed to only being able to detect inputs inside a specific window. In this project, JNativeHook's GlobalScreen and adapters were used, but I have overriden the action listeners and adapters with my own code to suit the needs of this project, specifically storage and replaying of inputs. When the program is running and recording is true (the user has started recording), every input action triggers a specific handler method which is able to encapsulate the event as an object to store in the recordedActions stack. During recording, a global variable of time is used to keep track of delays between actions. Every time a new action is recorded, the variable is then updated to the time in milliseconds when the action was performed. When the next action is then recorded, subtracting the last recorded time from the current system time gives us the delay, which is stored as part of the action object. Then, the time variable is updated. Thus, we are able to track the delays between actions in order to replay them at the right times. The different action classes (ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove) allow the program to store every input as an individual object. All these classes implement the Action interface, giving them all a press() method which is called when replaying. Here is an example of the handler method creating a new object: @Override public void nativeKeyPressed(NativeKeyEvent e) { // This method is called when a key is pressed; other methods handle other events. recordedActions.add(new KeyPress(e, Math.abs(System.currentTimeMillis()-time))); // Creates a new KeyPress object in the stack, parsing in the NativeKeyEvent generated by JNativeHook/GlobalScreen and the time since last recorded action time = System.currentTimeMillis(); // Updates variable time } // For context, the constructor for KeyPress is: public KeyPress(NativeKeyEvent ke, long delay) {...} The other adapter and conversion classes (SwingKeyAdapter, MouseCoordinateConverter, KeyLocationLookup, KeyCursorLookup) allow for conversion between different keycodes and screen sizes. The SwingKeyAdapter, KeyLocationLookup, and KeyCursorLookup classes convert VC keycodes used by NativeKeyEvent into VK keycodes used by KeyEvent. The MouseCoordinateConverter class allows for conversion between physical mouse cursor coordinate positions and scaled mouse cursor coordinate positions, allowing MouseMove to move the cursor to the correct point for all screen sizes on different computers. For example, the KeyPress class uses SwingKeyAdapter to translate a NativeKeyEvent keycode integer value to a KeyEvent keycode, which is what the robot from java.awt.Robot can interpret and use. @Override public void press() { robot.delay((int) delay); // Waits the millisecond amount as parsed from the constructor robot.keyPress(ska.getJavaKeyEvent(e).getKeyCode()); // Uses SwingKeyAdapter to convert keycode values } During recording, all input actions are created as new objects of their respective class and are stored in a stack until the user stops. Upon replaying the stored actions, the program will iterate through the stack and call each object's press() method to execute the action exactly as performed. for(Action i : recordedActions) { i.press(); /* The implementation of the Action inferface by all the input action classes allows me to call a generic .press() function */ } For more information, the full project can be found open-sourced on the Github repo. The downloadable jar file is not obfuscated and can be decompiled. Download The github repo can be found here . The jar executable can be downloaded here . Instructions for Use Start Recording Keystrokes: CTRL + SHIFT + R Stop Recording Keystrokes and Save: CTRL + SHIFT + S Replay Saved Keystroke Sequence: CTRL + SHIFT + 1 Initial Planning Chart Key Elements Action interface implemented by all the action/event classes: ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove, etc. Every action class follows the command archetype, allowing the encapsulation of a request as an object. KeyLocationLookup Singleton - single instance of the lookup object that is referenced every time a key conversion is needed Hashtable inside KeyLocationLookup to store NativeKeyEvent KeyLocations and corresponding KeyEvent integer values for conversion Mouse and Keyboard Adapters to listen for actions within the global screen. Those adapters also function as observers for the GlobalScreen. Stack to store the recorded actions Custom MouseCoordinatesConverter component that will convert true x, y mouse coordinates to relative x, y mouse coordinates scaled to each computer's unique screen size. Also functions as an adapter. State machine under GUILogger handling action transitions and entries when a key/mouse is pressed TreeMap under KeyCursorLookup to store NativeKeyEvent VC values and corresponding KeyEvent VK values","title":"Macro Maker"},{"location":"coding/macro/#macro-maker","text":"","title":"Macro Maker"},{"location":"coding/macro/#description","text":"The Macro project was my final project for Java Data Structures (H) in 10th grade, of which the requirements can be found here . The final product allows the user to start and end a global recording of all inputs to the computer. The global recording will inputs including mouse movements; mouse dragging; mouse clicking, releasing, and holding; key presses, releases, and hold times; and any simultaneous combination of events. The actions are also logged in the logger.out file. After the user begins recording, (CTRL + SHIFT+ R), all henceforth input actions are recorded until the user stops recording (CTRL + SHIFT + S). Upon replaying, the program will execute the actions exactly as recorded. The press() methods also delays the action's execution as to match the delays between actions of the original recording. The program does not interfere with input actions or other applications in any way.","title":"Description"},{"location":"coding/macro/#inspiration","text":"I've done a lot of scripting before, both static and dynamic through OCR. My goal with this project was to make a program that could record your actions and replay them with no need for hard coding or manual key press/mouse coordinate tracking. In the future, I plan to make make the project's logging function more useful, where the logging of actions into a seperate .txt document can function as a saved user macro sequence. Eventually I want to add a feature where the program is able to ingest a log file and replay the actions stored there, allowing users to save a specific macro multiple times past the closure of the JFrame.","title":"Inspiration"},{"location":"coding/macro/#method","text":"The main library that enabled the creation of this project is JNativeHook , which allows the global tracking of all actions that are sent into a computer, as opposed to only being able to detect inputs inside a specific window. In this project, JNativeHook's GlobalScreen and adapters were used, but I have overriden the action listeners and adapters with my own code to suit the needs of this project, specifically storage and replaying of inputs. When the program is running and recording is true (the user has started recording), every input action triggers a specific handler method which is able to encapsulate the event as an object to store in the recordedActions stack. During recording, a global variable of time is used to keep track of delays between actions. Every time a new action is recorded, the variable is then updated to the time in milliseconds when the action was performed. When the next action is then recorded, subtracting the last recorded time from the current system time gives us the delay, which is stored as part of the action object. Then, the time variable is updated. Thus, we are able to track the delays between actions in order to replay them at the right times. The different action classes (ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove) allow the program to store every input as an individual object. All these classes implement the Action interface, giving them all a press() method which is called when replaying. Here is an example of the handler method creating a new object: @Override public void nativeKeyPressed(NativeKeyEvent e) { // This method is called when a key is pressed; other methods handle other events. recordedActions.add(new KeyPress(e, Math.abs(System.currentTimeMillis()-time))); // Creates a new KeyPress object in the stack, parsing in the NativeKeyEvent generated by JNativeHook/GlobalScreen and the time since last recorded action time = System.currentTimeMillis(); // Updates variable time } // For context, the constructor for KeyPress is: public KeyPress(NativeKeyEvent ke, long delay) {...} The other adapter and conversion classes (SwingKeyAdapter, MouseCoordinateConverter, KeyLocationLookup, KeyCursorLookup) allow for conversion between different keycodes and screen sizes. The SwingKeyAdapter, KeyLocationLookup, and KeyCursorLookup classes convert VC keycodes used by NativeKeyEvent into VK keycodes used by KeyEvent. The MouseCoordinateConverter class allows for conversion between physical mouse cursor coordinate positions and scaled mouse cursor coordinate positions, allowing MouseMove to move the cursor to the correct point for all screen sizes on different computers. For example, the KeyPress class uses SwingKeyAdapter to translate a NativeKeyEvent keycode integer value to a KeyEvent keycode, which is what the robot from java.awt.Robot can interpret and use. @Override public void press() { robot.delay((int) delay); // Waits the millisecond amount as parsed from the constructor robot.keyPress(ska.getJavaKeyEvent(e).getKeyCode()); // Uses SwingKeyAdapter to convert keycode values } During recording, all input actions are created as new objects of their respective class and are stored in a stack until the user stops. Upon replaying the stored actions, the program will iterate through the stack and call each object's press() method to execute the action exactly as performed. for(Action i : recordedActions) { i.press(); /* The implementation of the Action inferface by all the input action classes allows me to call a generic .press() function */ } For more information, the full project can be found open-sourced on the Github repo. The downloadable jar file is not obfuscated and can be decompiled.","title":"Method"},{"location":"coding/macro/#download","text":"","title":"Download"},{"location":"coding/macro/#the-github-repo-can-be-found-here","text":"","title":"The github repo can be found here."},{"location":"coding/macro/#the-jar-executable-can-be-downloaded-here","text":"","title":"The jar executable can be downloaded here."},{"location":"coding/macro/#instructions-for-use","text":"Start Recording Keystrokes: CTRL + SHIFT + R Stop Recording Keystrokes and Save: CTRL + SHIFT + S Replay Saved Keystroke Sequence: CTRL + SHIFT + 1","title":"Instructions for Use"},{"location":"coding/macro/#initial-planning-chart","text":"","title":"Initial Planning Chart"},{"location":"coding/macro/#key-elements","text":"Action interface implemented by all the action/event classes: ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove, etc. Every action class follows the command archetype, allowing the encapsulation of a request as an object. KeyLocationLookup Singleton - single instance of the lookup object that is referenced every time a key conversion is needed Hashtable inside KeyLocationLookup to store NativeKeyEvent KeyLocations and corresponding KeyEvent integer values for conversion Mouse and Keyboard Adapters to listen for actions within the global screen. Those adapters also function as observers for the GlobalScreen. Stack to store the recorded actions Custom MouseCoordinatesConverter component that will convert true x, y mouse coordinates to relative x, y mouse coordinates scaled to each computer's unique screen size. Also functions as an adapter. State machine under GUILogger handling action transitions and entries when a key/mouse is pressed TreeMap under KeyCursorLookup to store NativeKeyEvent VC values and corresponding KeyEvent VK values","title":"Key Elements"},{"location":"edm2/lessons/fusionpart1/","text":"Deep Dive into Fusion 360 (Part 1) Self-Evaluation Beforehand Before starting this project, I already had some prior experience using Fusion360. However, in the pas I always struggled with modifying geometry for a specific command and navigating different sketches. I was able to overcome this through practicing using the bar at the bottom. Storage Box Before starting working with Fusion, I was required to make a storage box. I decided to reuse a box that I already had from making it during Fab Academy. My documentation for making the box can be found here , containing a description on how I made the box. Navigating the Fusion 360 User Interface This is the application bar. This bar contains the data panel, file menu, save button, and undo/redo buttons. This is also where all open projects are displayed in a tabs format. This is the data panel. The data panel functions as the file explorer for Fusion files and directories, along with managing sharing settings. These are the Profile and Help settings. This area contains notifications, statuses, and the profile button which allows modification of preferences and profile settings. This is the toolbar. The toolbar contains all of the tools/actions. The tools in the toolbar are organized by category: solid, surface, mesh, sheet metal, plastic, and utilities. The categories can be selected at the top bar, and the tools themselves are in the main rectangular panel. This is the browser. The browser allows easy access and viewing of all objects within the design. The browser allows the user to change the visibility of objects and change file units. The browser is structured like a file explorer. This is the view cube. The view cube allows orbiting around the design, and snapping to a specific viewing angle. The home button will orbit to the default home viewing position. This is the canvas. The canvas is where all the designing takes place. Right clicking in the canvas will access the marking menu/right-click menu which allows quick access of specific tools and commands. These are the navigation bar and display settings. The navigation bar is used to move around the design more accurately than the view cube. The display settings control cosmetic appearances. This is the view of the canvas from multiple perspectives at once, through use of the Viewports -> Multiple Views setting. Interface Parts List Pro Tricks Utilize sketch constraints to secure specific geometry. Use the timeline to modify sketches that have other geometry defined on top of them. Paperclip My file for the paperclip design in Fusion360 can be downloaded here . The paperclip's design mainly used constraints and the sweep command. I learned how constraints can be used to ensure that geometry remains strictly vertical/horizontal/tangent and how the sweep tool uses a sweep path and selects an object to be swept. Glass Bottle My file for the glass bottle design in Fusion360 can be downloaded here . The glass bottle's design process mainly focused on inserting a reference image and using the revolve command. I learned how to insert an image to help as I designed and how to manually adjust objects by a set distance. Problems Encountered The main problem I encountered while starting my exploration of Fusion 360 was a lack of up-to-date tutorials. The video series that I followed, Learn Fusion 360 in 30 Days for Complete Beginners, was made a year ago. As such, some of the tools and defaults were different from last year and now. Different placements of tools was not a large issue as I could simply navigate or search to find the correct tool. However, some commands had different effects on the model which I had to manually fix. For example, when inserting a reference image as a canvas, it would create a new origin point which was not the case in the videos. As such, I had to manually move the entire design up by 100mm in order to have it all start on the origin's z-plane.","title":"Deep Dive into Fusion 360 (Part 1)"},{"location":"edm2/lessons/fusionpart1/#deep-dive-into-fusion-360-part-1","text":"","title":"Deep Dive into Fusion 360 (Part 1)"},{"location":"edm2/lessons/fusionpart1/#self-evaluation-beforehand","text":"Before starting this project, I already had some prior experience using Fusion360. However, in the pas I always struggled with modifying geometry for a specific command and navigating different sketches. I was able to overcome this through practicing using the bar at the bottom.","title":"Self-Evaluation Beforehand"},{"location":"edm2/lessons/fusionpart1/#storage-box","text":"Before starting working with Fusion, I was required to make a storage box. I decided to reuse a box that I already had from making it during Fab Academy. My documentation for making the box can be found here , containing a description on how I made the box.","title":"Storage Box"},{"location":"edm2/lessons/fusionpart1/#navigating-the-fusion-360-user-interface","text":"This is the application bar. This bar contains the data panel, file menu, save button, and undo/redo buttons. This is also where all open projects are displayed in a tabs format. This is the data panel. The data panel functions as the file explorer for Fusion files and directories, along with managing sharing settings. These are the Profile and Help settings. This area contains notifications, statuses, and the profile button which allows modification of preferences and profile settings. This is the toolbar. The toolbar contains all of the tools/actions. The tools in the toolbar are organized by category: solid, surface, mesh, sheet metal, plastic, and utilities. The categories can be selected at the top bar, and the tools themselves are in the main rectangular panel. This is the browser. The browser allows easy access and viewing of all objects within the design. The browser allows the user to change the visibility of objects and change file units. The browser is structured like a file explorer. This is the view cube. The view cube allows orbiting around the design, and snapping to a specific viewing angle. The home button will orbit to the default home viewing position. This is the canvas. The canvas is where all the designing takes place. Right clicking in the canvas will access the marking menu/right-click menu which allows quick access of specific tools and commands. These are the navigation bar and display settings. The navigation bar is used to move around the design more accurately than the view cube. The display settings control cosmetic appearances. This is the view of the canvas from multiple perspectives at once, through use of the Viewports -> Multiple Views setting.","title":"Navigating the Fusion 360 User Interface"},{"location":"edm2/lessons/fusionpart1/#interface-parts-list","text":"","title":"Interface Parts List"},{"location":"edm2/lessons/fusionpart1/#pro-tricks","text":"Utilize sketch constraints to secure specific geometry. Use the timeline to modify sketches that have other geometry defined on top of them.","title":"Pro Tricks"},{"location":"edm2/lessons/fusionpart1/#paperclip","text":"My file for the paperclip design in Fusion360 can be downloaded here . The paperclip's design mainly used constraints and the sweep command. I learned how constraints can be used to ensure that geometry remains strictly vertical/horizontal/tangent and how the sweep tool uses a sweep path and selects an object to be swept.","title":"Paperclip"},{"location":"edm2/lessons/fusionpart1/#glass-bottle","text":"My file for the glass bottle design in Fusion360 can be downloaded here . The glass bottle's design process mainly focused on inserting a reference image and using the revolve command. I learned how to insert an image to help as I designed and how to manually adjust objects by a set distance.","title":"Glass Bottle"},{"location":"edm2/lessons/fusionpart1/#problems-encountered","text":"The main problem I encountered while starting my exploration of Fusion 360 was a lack of up-to-date tutorials. The video series that I followed, Learn Fusion 360 in 30 Days for Complete Beginners, was made a year ago. As such, some of the tools and defaults were different from last year and now. Different placements of tools was not a large issue as I could simply navigate or search to find the correct tool. However, some commands had different effects on the model which I had to manually fix. For example, when inserting a reference image as a canvas, it would create a new origin point which was not the case in the videos. As such, I had to manually move the entire design up by 100mm in order to have it all start on the origin's z-plane.","title":"Problems Encountered"},{"location":"edm2/lessons/fusionpart2/","text":"Deep Dive into Fusion 360 (Part 2) Flattened Cone Warmup As a warmup before starting class one day, I designed a flattened cone to the following specifications: I first made a sketch on the ZY-plane in Fusion360, where I created a quadrilateral to match the one shown in the requirements image. I then used the Revolve tool to revolve the entire quadrilateral sketch 360 degrees around the Z axis to create a full flattened cone: Finally, since the warmup asked me for a 2D drawing, I generated a 2D drawing based off the design. Bicycle Rack Design As a review and challenge for my current Fusion360 knowledge, I was asked to design a bicycle rack to a set of specified dimensions. Here is the image with dimensions that I was designing off of: I first created a sketch on the ZY-plane and used the line and circle tools to design my sketch to match the specified dimensions: I then created a new sketch on the XY-plane and created a circle with a diameter of 4mm. To make the design 3D, I used the sweep tool to sweep the circle along the path of the bike rack. Generating 2D Drawings I used Kevin Kennedy's Youtube Video to learn how to generate 2D drawings in Fusion. To make a 2D drawing, I first navigated to the design I wanted to make a drawing of. I then clicked on the File dropdown menu, and clicked New Drawing -> From Design , making sure to select the object I wanted a drawing of. To practice making 2D drawings, I generated a drawing from the Fusion360 example design for a connector joint: I then created a 2D drawing of my bicycle rack design: Lego Technic Brick Design For more practice designing objects in Fusion, I was asked to create a Lego Technic Brick from the following image to its dimensions: There were many possible approaches to designing the brick, but I started with a 3D rectangular prism to match the general specifications of the actual brick part of the Lego. From there, I created concentric circles on the sides and the top, and extruded them (both as a new body and as a hole function) to the dimensions in the image. To create the Lego connectors at the bottom, I created 3 circles centered at the midpoints between the radii of the circle connectors on the top of the Lego brick. I then shelled the entire rectangular prism to hollow it out. Here is my completed design: Custom Lego Design I was then challenged to design a custom lego brick. The following image shows the brick that I was assigned to design:","title":"Deep Dive into Fusion 360 (Part 2)"},{"location":"edm2/lessons/fusionpart2/#deep-dive-into-fusion-360-part-2","text":"","title":"Deep Dive into Fusion 360 (Part 2)"},{"location":"edm2/lessons/fusionpart2/#flattened-cone-warmup","text":"As a warmup before starting class one day, I designed a flattened cone to the following specifications: I first made a sketch on the ZY-plane in Fusion360, where I created a quadrilateral to match the one shown in the requirements image. I then used the Revolve tool to revolve the entire quadrilateral sketch 360 degrees around the Z axis to create a full flattened cone: Finally, since the warmup asked me for a 2D drawing, I generated a 2D drawing based off the design.","title":"Flattened Cone Warmup"},{"location":"edm2/lessons/fusionpart2/#bicycle-rack-design","text":"As a review and challenge for my current Fusion360 knowledge, I was asked to design a bicycle rack to a set of specified dimensions. Here is the image with dimensions that I was designing off of: I first created a sketch on the ZY-plane and used the line and circle tools to design my sketch to match the specified dimensions: I then created a new sketch on the XY-plane and created a circle with a diameter of 4mm. To make the design 3D, I used the sweep tool to sweep the circle along the path of the bike rack.","title":"Bicycle Rack Design"},{"location":"edm2/lessons/fusionpart2/#generating-2d-drawings","text":"I used Kevin Kennedy's Youtube Video to learn how to generate 2D drawings in Fusion. To make a 2D drawing, I first navigated to the design I wanted to make a drawing of. I then clicked on the File dropdown menu, and clicked New Drawing -> From Design , making sure to select the object I wanted a drawing of. To practice making 2D drawings, I generated a drawing from the Fusion360 example design for a connector joint: I then created a 2D drawing of my bicycle rack design:","title":"Generating 2D Drawings"},{"location":"edm2/lessons/fusionpart2/#lego-technic-brick-design","text":"For more practice designing objects in Fusion, I was asked to create a Lego Technic Brick from the following image to its dimensions: There were many possible approaches to designing the brick, but I started with a 3D rectangular prism to match the general specifications of the actual brick part of the Lego. From there, I created concentric circles on the sides and the top, and extruded them (both as a new body and as a hole function) to the dimensions in the image. To create the Lego connectors at the bottom, I created 3 circles centered at the midpoints between the radii of the circle connectors on the top of the Lego brick. I then shelled the entire rectangular prism to hollow it out. Here is my completed design:","title":"Lego Technic Brick Design"},{"location":"edm2/lessons/fusionpart2/#custom-lego-design","text":"I was then challenged to design a custom lego brick. The following image shows the brick that I was assigned to design:","title":"Custom Lego Design"}]}