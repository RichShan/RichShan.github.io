{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Richard Shan","title":"Home"},{"location":"#richard-shan","text":"","title":"Richard Shan"},{"location":"about/","text":"About Me","title":"About"},{"location":"about/#about-me","text":"","title":"About Me"},{"location":"coding/","text":"Here are some of my coding projects: Macro Maker","title":"Coding"},{"location":"coding/#here-are-some-of-my-coding-projects","text":"","title":"Here are some of my coding projects:"},{"location":"coding/#macro-maker","text":"","title":"Macro Maker"},{"location":"edm2/","text":"Engineering 2 Deep Dive into Fusion 360 Pt. 1 Deep Dive into Fusion 360 Pt. 2 Milling About","title":"Engineering 2"},{"location":"edm2/#engineering-2","text":"","title":"Engineering 2"},{"location":"edm2/#deep-dive-into-fusion-360-pt-1","text":"","title":"Deep Dive into Fusion 360 Pt. 1 "},{"location":"edm2/#deep-dive-into-fusion-360-pt-2","text":"","title":"Deep Dive into Fusion 360 Pt. 2 "},{"location":"edm2/#milling-about","text":"","title":"Milling About "},{"location":"coding/macro/","text":"Macro Maker Description The Macro project was my final project for Java Data Structures (H) in 10th grade, of which the requirements can be found here . The final product allows the user to start and end a global recording of all inputs to the computer. The global recording will inputs including mouse movements; mouse dragging; mouse clicking, releasing, and holding; key presses, releases, and hold times; and any simultaneous combination of events. The actions are also logged in the logger.out file. After the user begins recording, (CTRL + SHIFT+ R), all henceforth input actions are recorded until the user stops recording (CTRL + SHIFT + S). Upon replaying, the program will execute the actions exactly as recorded. The press() methods also delays the action's execution as to match the delays between actions of the original recording. The program does not interfere with input actions or other applications in any way. Inspiration I've done a lot of scripting before, both static and dynamic through OCR. My goal with this project was to make a program that could record your actions and replay them with no need for hard coding or manual key press/mouse coordinate tracking. In the future, I plan to make make the project's logging function more useful, where the logging of actions into a seperate .txt document can function as a saved user macro sequence. Eventually I want to add a feature where the program is able to ingest a log file and replay the actions stored there, allowing users to save a specific macro multiple times past the closure of the JFrame. Method The main library that enabled the creation of this project is JNativeHook , which allows the global tracking of all actions that are sent into a computer, as opposed to only being able to detect inputs inside a specific window. In this project, JNativeHook's GlobalScreen and adapters were used, but I have overriden the action listeners and adapters with my own code to suit the needs of this project, specifically storage and replaying of inputs. When the program is running and recording is true (the user has started recording), every input action triggers a specific handler method which is able to encapsulate the event as an object to store in the recordedActions stack. During recording, a global variable of time is used to keep track of delays between actions. Every time a new action is recorded, the variable is then updated to the time in milliseconds when the action was performed. When the next action is then recorded, subtracting the last recorded time from the current system time gives us the delay, which is stored as part of the action object. Then, the time variable is updated. Thus, we are able to track the delays between actions in order to replay them at the right times. The different action classes (ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove) allow the program to store every input as an individual object. All these classes implement the Action interface, giving them all a press() method which is called when replaying. Here is an example of the handler method creating a new object: @Override public void nativeKeyPressed(NativeKeyEvent e) { // This method is called when a key is pressed; other methods handle other events. recordedActions.add(new KeyPress(e, Math.abs(System.currentTimeMillis()-time))); // Creates a new KeyPress object in the stack, parsing in the NativeKeyEvent generated by JNativeHook/GlobalScreen and the time since last recorded action time = System.currentTimeMillis(); // Updates variable time } // For context, the constructor for KeyPress is: public KeyPress(NativeKeyEvent ke, long delay) {...} The other adapter and conversion classes (SwingKeyAdapter, MouseCoordinateConverter, KeyLocationLookup, KeyCursorLookup) allow for conversion between different keycodes and screen sizes. The SwingKeyAdapter, KeyLocationLookup, and KeyCursorLookup classes convert VC keycodes used by NativeKeyEvent into VK keycodes used by KeyEvent. The MouseCoordinateConverter class allows for conversion between physical mouse cursor coordinate positions and scaled mouse cursor coordinate positions, allowing MouseMove to move the cursor to the correct point for all screen sizes on different computers. For example, the KeyPress class uses SwingKeyAdapter to translate a NativeKeyEvent keycode integer value to a KeyEvent keycode, which is what the robot from java.awt.Robot can interpret and use. @Override public void press() { robot.delay((int) delay); // Waits the millisecond amount as parsed from the constructor robot.keyPress(ska.getJavaKeyEvent(e).getKeyCode()); // Uses SwingKeyAdapter to convert keycode values } During recording, all input actions are created as new objects of their respective class and are stored in a stack until the user stops. Upon replaying the stored actions, the program will iterate through the stack and call each object's press() method to execute the action exactly as performed. for(Action i : recordedActions) { i.press(); /* The implementation of the Action inferface by all the input action classes allows me to call a generic .press() function */ } For more information, the full project can be found open-sourced on the Github repo. The downloadable jar file is not obfuscated and can be decompiled. Download The github repo can be found here . The jar executable can be downloaded here . Instructions for Use Start Recording Keystrokes: CTRL + SHIFT + R Stop Recording Keystrokes and Save: CTRL + SHIFT + S Replay Saved Keystroke Sequence: CTRL + SHIFT + 1 Initial Planning Chart Key Elements Action interface implemented by all the action/event classes: ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove, etc. Every action class follows the command archetype, allowing the encapsulation of a request as an object. KeyLocationLookup Singleton - single instance of the lookup object that is referenced every time a key conversion is needed Hashtable inside KeyLocationLookup to store NativeKeyEvent KeyLocations and corresponding KeyEvent integer values for conversion Mouse and Keyboard Adapters to listen for actions within the global screen. Those adapters also function as observers for the GlobalScreen. Stack to store the recorded actions Custom MouseCoordinatesConverter component that will convert true x, y mouse coordinates to relative x, y mouse coordinates scaled to each computer's unique screen size. Also functions as an adapter. State machine under GUILogger handling action transitions and entries when a key/mouse is pressed TreeMap under KeyCursorLookup to store NativeKeyEvent VC values and corresponding KeyEvent VK values","title":"Macro Maker"},{"location":"coding/macro/#macro-maker","text":"","title":"Macro Maker"},{"location":"coding/macro/#description","text":"The Macro project was my final project for Java Data Structures (H) in 10th grade, of which the requirements can be found here . The final product allows the user to start and end a global recording of all inputs to the computer. The global recording will inputs including mouse movements; mouse dragging; mouse clicking, releasing, and holding; key presses, releases, and hold times; and any simultaneous combination of events. The actions are also logged in the logger.out file. After the user begins recording, (CTRL + SHIFT+ R), all henceforth input actions are recorded until the user stops recording (CTRL + SHIFT + S). Upon replaying, the program will execute the actions exactly as recorded. The press() methods also delays the action's execution as to match the delays between actions of the original recording. The program does not interfere with input actions or other applications in any way.","title":"Description"},{"location":"coding/macro/#inspiration","text":"I've done a lot of scripting before, both static and dynamic through OCR. My goal with this project was to make a program that could record your actions and replay them with no need for hard coding or manual key press/mouse coordinate tracking. In the future, I plan to make make the project's logging function more useful, where the logging of actions into a seperate .txt document can function as a saved user macro sequence. Eventually I want to add a feature where the program is able to ingest a log file and replay the actions stored there, allowing users to save a specific macro multiple times past the closure of the JFrame.","title":"Inspiration"},{"location":"coding/macro/#method","text":"The main library that enabled the creation of this project is JNativeHook , which allows the global tracking of all actions that are sent into a computer, as opposed to only being able to detect inputs inside a specific window. In this project, JNativeHook's GlobalScreen and adapters were used, but I have overriden the action listeners and adapters with my own code to suit the needs of this project, specifically storage and replaying of inputs. When the program is running and recording is true (the user has started recording), every input action triggers a specific handler method which is able to encapsulate the event as an object to store in the recordedActions stack. During recording, a global variable of time is used to keep track of delays between actions. Every time a new action is recorded, the variable is then updated to the time in milliseconds when the action was performed. When the next action is then recorded, subtracting the last recorded time from the current system time gives us the delay, which is stored as part of the action object. Then, the time variable is updated. Thus, we are able to track the delays between actions in order to replay them at the right times. The different action classes (ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove) allow the program to store every input as an individual object. All these classes implement the Action interface, giving them all a press() method which is called when replaying. Here is an example of the handler method creating a new object: @Override public void nativeKeyPressed(NativeKeyEvent e) { // This method is called when a key is pressed; other methods handle other events. recordedActions.add(new KeyPress(e, Math.abs(System.currentTimeMillis()-time))); // Creates a new KeyPress object in the stack, parsing in the NativeKeyEvent generated by JNativeHook/GlobalScreen and the time since last recorded action time = System.currentTimeMillis(); // Updates variable time } // For context, the constructor for KeyPress is: public KeyPress(NativeKeyEvent ke, long delay) {...} The other adapter and conversion classes (SwingKeyAdapter, MouseCoordinateConverter, KeyLocationLookup, KeyCursorLookup) allow for conversion between different keycodes and screen sizes. The SwingKeyAdapter, KeyLocationLookup, and KeyCursorLookup classes convert VC keycodes used by NativeKeyEvent into VK keycodes used by KeyEvent. The MouseCoordinateConverter class allows for conversion between physical mouse cursor coordinate positions and scaled mouse cursor coordinate positions, allowing MouseMove to move the cursor to the correct point for all screen sizes on different computers. For example, the KeyPress class uses SwingKeyAdapter to translate a NativeKeyEvent keycode integer value to a KeyEvent keycode, which is what the robot from java.awt.Robot can interpret and use. @Override public void press() { robot.delay((int) delay); // Waits the millisecond amount as parsed from the constructor robot.keyPress(ska.getJavaKeyEvent(e).getKeyCode()); // Uses SwingKeyAdapter to convert keycode values } During recording, all input actions are created as new objects of their respective class and are stored in a stack until the user stops. Upon replaying the stored actions, the program will iterate through the stack and call each object's press() method to execute the action exactly as performed. for(Action i : recordedActions) { i.press(); /* The implementation of the Action inferface by all the input action classes allows me to call a generic .press() function */ } For more information, the full project can be found open-sourced on the Github repo. The downloadable jar file is not obfuscated and can be decompiled.","title":"Method"},{"location":"coding/macro/#download","text":"","title":"Download"},{"location":"coding/macro/#the-github-repo-can-be-found-here","text":"","title":"The github repo can be found here."},{"location":"coding/macro/#the-jar-executable-can-be-downloaded-here","text":"","title":"The jar executable can be downloaded here."},{"location":"coding/macro/#instructions-for-use","text":"Start Recording Keystrokes: CTRL + SHIFT + R Stop Recording Keystrokes and Save: CTRL + SHIFT + S Replay Saved Keystroke Sequence: CTRL + SHIFT + 1","title":"Instructions for Use"},{"location":"coding/macro/#initial-planning-chart","text":"","title":"Initial Planning Chart"},{"location":"coding/macro/#key-elements","text":"Action interface implemented by all the action/event classes: ClickPress, ClickRelease, KeyPress, KeyRelease, MouseMove, etc. Every action class follows the command archetype, allowing the encapsulation of a request as an object. KeyLocationLookup Singleton - single instance of the lookup object that is referenced every time a key conversion is needed Hashtable inside KeyLocationLookup to store NativeKeyEvent KeyLocations and corresponding KeyEvent integer values for conversion Mouse and Keyboard Adapters to listen for actions within the global screen. Those adapters also function as observers for the GlobalScreen. Stack to store the recorded actions Custom MouseCoordinatesConverter component that will convert true x, y mouse coordinates to relative x, y mouse coordinates scaled to each computer's unique screen size. Also functions as an adapter. State machine under GUILogger handling action transitions and entries when a key/mouse is pressed TreeMap under KeyCursorLookup to store NativeKeyEvent VC values and corresponding KeyEvent VK values","title":"Key Elements"},{"location":"edm2/lessons/fusionpart1/","text":"Deep Dive into Fusion 360 (Part 1) Self-Evaluation Beforehand Before starting this project, I already had some prior experience using Fusion360. However, in the pas I always struggled with modifying geometry for a specific command and navigating different sketches. I was able to overcome this through practicing using the bar at the bottom. Storage Box Before starting working with Fusion, I was required to make a storage box. I decided to reuse a box that I already had from making it during Fab Academy. My documentation for making the box can be found here , containing a description on how I made the box. Navigating the Fusion 360 User Interface This is the application bar. This bar contains the data panel, file menu, save button, and undo/redo buttons. This is also where all open projects are displayed in a tabs format. This is the data panel. The data panel functions as the file explorer for Fusion files and directories, along with managing sharing settings. These are the Profile and Help settings. This area contains notifications, statuses, and the profile button which allows modification of preferences and profile settings. This is the toolbar. The toolbar contains all of the tools/actions. The tools in the toolbar are organized by category: solid, surface, mesh, sheet metal, plastic, and utilities. The categories can be selected at the top bar, and the tools themselves are in the main rectangular panel. This is the browser. The browser allows easy access and viewing of all objects within the design. The browser allows the user to change the visibility of objects and change file units. The browser is structured like a file explorer. This is the view cube. The view cube allows orbiting around the design, and snapping to a specific viewing angle. The home button will orbit to the default home viewing position. This is the canvas. The canvas is where all the designing takes place. Right clicking in the canvas will access the marking menu/right-click menu which allows quick access of specific tools and commands. These are the navigation bar and display settings. The navigation bar is used to move around the design more accurately than the view cube. The display settings control cosmetic appearances. This is the view of the canvas from multiple perspectives at once, through use of the Viewports -> Multiple Views setting. Interface Parts List Pro Tricks Utilize sketch constraints to secure specific geometry. Use the timeline to modify sketches that have other geometry defined on top of them. Paperclip My file for the paperclip design in Fusion360 can be downloaded here . The paperclip's design mainly used constraints and the sweep command. I learned how constraints can be used to ensure that geometry remains strictly vertical/horizontal/tangent and how the sweep tool uses a sweep path and selects an object to be swept. Glass Bottle My file for the glass bottle design in Fusion360 can be downloaded here . The glass bottle's design process mainly focused on inserting a reference image and using the revolve command. I learned how to insert an image to help as I designed and how to manually adjust objects by a set distance. Problems Encountered The main problem I encountered while starting my exploration of Fusion 360 was a lack of up-to-date tutorials. The video series that I followed, Learn Fusion 360 in 30 Days for Complete Beginners, was made a year ago. As such, some of the tools and defaults were different from last year and now. Different placements of tools was not a large issue as I could simply navigate or search to find the correct tool. However, some commands had different effects on the model which I had to manually fix. For example, when inserting a reference image as a canvas, it would create a new origin point which was not the case in the videos. As such, I had to manually move the entire design up by 100mm in order to have it all start on the origin's z-plane.","title":"Deep Dive into Fusion 360 (Part 1)"},{"location":"edm2/lessons/fusionpart1/#deep-dive-into-fusion-360-part-1","text":"","title":"Deep Dive into Fusion 360 (Part 1)"},{"location":"edm2/lessons/fusionpart1/#self-evaluation-beforehand","text":"Before starting this project, I already had some prior experience using Fusion360. However, in the pas I always struggled with modifying geometry for a specific command and navigating different sketches. I was able to overcome this through practicing using the bar at the bottom.","title":"Self-Evaluation Beforehand"},{"location":"edm2/lessons/fusionpart1/#storage-box","text":"Before starting working with Fusion, I was required to make a storage box. I decided to reuse a box that I already had from making it during Fab Academy. My documentation for making the box can be found here , containing a description on how I made the box.","title":"Storage Box"},{"location":"edm2/lessons/fusionpart1/#navigating-the-fusion-360-user-interface","text":"This is the application bar. This bar contains the data panel, file menu, save button, and undo/redo buttons. This is also where all open projects are displayed in a tabs format. This is the data panel. The data panel functions as the file explorer for Fusion files and directories, along with managing sharing settings. These are the Profile and Help settings. This area contains notifications, statuses, and the profile button which allows modification of preferences and profile settings. This is the toolbar. The toolbar contains all of the tools/actions. The tools in the toolbar are organized by category: solid, surface, mesh, sheet metal, plastic, and utilities. The categories can be selected at the top bar, and the tools themselves are in the main rectangular panel. This is the browser. The browser allows easy access and viewing of all objects within the design. The browser allows the user to change the visibility of objects and change file units. The browser is structured like a file explorer. This is the view cube. The view cube allows orbiting around the design, and snapping to a specific viewing angle. The home button will orbit to the default home viewing position. This is the canvas. The canvas is where all the designing takes place. Right clicking in the canvas will access the marking menu/right-click menu which allows quick access of specific tools and commands. These are the navigation bar and display settings. The navigation bar is used to move around the design more accurately than the view cube. The display settings control cosmetic appearances. This is the view of the canvas from multiple perspectives at once, through use of the Viewports -> Multiple Views setting.","title":"Navigating the Fusion 360 User Interface"},{"location":"edm2/lessons/fusionpart1/#interface-parts-list","text":"","title":"Interface Parts List"},{"location":"edm2/lessons/fusionpart1/#pro-tricks","text":"Utilize sketch constraints to secure specific geometry. Use the timeline to modify sketches that have other geometry defined on top of them.","title":"Pro Tricks"},{"location":"edm2/lessons/fusionpart1/#paperclip","text":"My file for the paperclip design in Fusion360 can be downloaded here . The paperclip's design mainly used constraints and the sweep command. I learned how constraints can be used to ensure that geometry remains strictly vertical/horizontal/tangent and how the sweep tool uses a sweep path and selects an object to be swept.","title":"Paperclip"},{"location":"edm2/lessons/fusionpart1/#glass-bottle","text":"My file for the glass bottle design in Fusion360 can be downloaded here . The glass bottle's design process mainly focused on inserting a reference image and using the revolve command. I learned how to insert an image to help as I designed and how to manually adjust objects by a set distance.","title":"Glass Bottle"},{"location":"edm2/lessons/fusionpart1/#problems-encountered","text":"The main problem I encountered while starting my exploration of Fusion 360 was a lack of up-to-date tutorials. The video series that I followed, Learn Fusion 360 in 30 Days for Complete Beginners, was made a year ago. As such, some of the tools and defaults were different from last year and now. Different placements of tools was not a large issue as I could simply navigate or search to find the correct tool. However, some commands had different effects on the model which I had to manually fix. For example, when inserting a reference image as a canvas, it would create a new origin point which was not the case in the videos. As such, I had to manually move the entire design up by 100mm in order to have it all start on the origin's z-plane.","title":"Problems Encountered"},{"location":"edm2/lessons/fusionpart2/","text":"Deep Dive into Fusion 360 (Part 2) Flattened Cone Warmup As a warmup before starting class one day, I designed a flattened cone to the following specifications: I first made a sketch on the ZY-plane in Fusion360, where I created a quadrilateral to match the one shown in the requirements image. I then used the Revolve tool to revolve the entire quadrilateral sketch 360 degrees around the Z axis to create a full flattened cone: Finally, since the warmup asked me for a 2D drawing, I generated a 2D drawing based off the design. Bicycle Rack Design As a review and challenge for my current Fusion360 knowledge, I was asked to design a bicycle rack to a set of specified dimensions. Here is the image with dimensions that I was designing off of: I first created a sketch on the ZY-plane and used the line and circle tools to design my sketch to match the specified dimensions: I then created a new sketch on the XY-plane and created a circle with a diameter of 4mm. To make the design 3D, I used the sweep tool to sweep the circle along the path of the bike rack. Generating 2D Drawings I used Kevin Kennedy's Youtube Video to learn how to generate 2D drawings in Fusion. To make a 2D drawing, I first navigated to the design I wanted to make a drawing of. I then clicked on the File dropdown menu, and clicked New Drawing -> From Design , making sure to select the object I wanted a drawing of. To practice making 2D drawings, I generated a drawing from the Fusion360 example design for a connector joint: I then created a 2D drawing of my bicycle rack design: Lego Technic Brick Design For more practice designing objects in Fusion, I was asked to create a Lego Technic Brick from the following image to its dimensions: There were many possible approaches to designing the brick, but I started with a 3D rectangular prism to match the general specifications of the actual brick part of the Lego. From there, I created concentric circles on the sides and the top, and extruded them (both as a new body and as a hole function) to the dimensions in the image. To create the Lego connectors at the bottom, I created 3 circles centered at the midpoints between the radii of the circle connectors on the top of the Lego brick. I then shelled the entire rectangular prism to hollow it out. Here is my completed design: Custom Lego Design I was then challenged to design a custom lego brick. I started designing the brick from the main Lego body as it was relatively simply and would be a good base to design the appendages from. I then sketched and extruded one appendage, mirroring it to all 4 sides of the Lego brick. Lastly, I touched up the brick, adding things like the Lego plus connector joint and smoothing out issues with the spline curve extrursion. The following image shows the brick that I was assigned to design. I first used digital calipers to measure every dimension of the Lego brick. I would continue to use these calipers as I went through the designing process to ensure my dimensions were correct. I started off with designing the body of the custom brick. I designed a sketch on the XY plane and extruded it to create the main body of the brick: Next, I created a sketch to design one of the four appendages coming out of the Lego brick's body. I then mirrored it to all four positions and extruded them. I then created and extruded a spline curve on the side of the Lego brick to mimic the curve of the real brick. To create the plus axle joint I created another sketch in the shape of the plus, which I then mirrored and extruded. Here was my final recreation of the Lego brick, shown in both 2D and 3D views: Trading Lego Designs Next, I traded Lego designs with a partner. We sent each other our respective 2D views of our design with dimensions. I would then model his Lego brick based solely on the 2D design he sent me: I started the design by creating a sketch for the base of the Lego. I then extruded each of the base's parts to the proper length. I extruded the area between the concentric circles and the two outer rectangles as Lego connectors. I then created a sphere above the base, which I subsequently cut in half. Next, I shelled the semisphere to make it hollow. I then created 3 sketches on planes oriented 120 degrees from each other. I created a rectangle perpendicular to each of the three planes. I then used the sweep tool to sweep the rectangle on the path, creating a hole that fits to the spherical shape. Here are the 3D and 2D views of the final design: Custom Object Design To further practice using Fusion, I decided to design a pen holder, of which the tutorial can be found here . My Fusion360 file of the design can be downloaded here . To make the design, I started off with shelling a large cylinder. I then created a polygon on the XZ plane and extruded it as a hole onto the surface of the cylinder. I then repeated this across the whole surface of the cylinder via the rectangular and circular pattern tools. To print this file, I first exported the file out of Fusion360 and opened it in PrusaSlicer. I then sliced the file with grid supports and a 15% infill, scaling the design down to finish printing under an hour. Since I was printing at home, my printer wasn't setup with wifi capabilities, so I saved the sliced file onto a flash drive which I then plugged into the printer. Because the hexagonal patterning was so thin, when I originally printed the design, it was heavily reliant on supports. Those supports obscured the actual design and when I tried to peel them away, the entire design crumbled. To solve this issue, I first upscaled the print which made the mesh more stable. I also changed the support type to be organic instead of grid, which minimized the points of contact between the supports and the actual print. This time, the supports were a lot easier to remove and did not damage the structure","title":"Deep Dive into Fusion 360 (Part 2)"},{"location":"edm2/lessons/fusionpart2/#deep-dive-into-fusion-360-part-2","text":"","title":"Deep Dive into Fusion 360 (Part 2)"},{"location":"edm2/lessons/fusionpart2/#flattened-cone-warmup","text":"As a warmup before starting class one day, I designed a flattened cone to the following specifications: I first made a sketch on the ZY-plane in Fusion360, where I created a quadrilateral to match the one shown in the requirements image. I then used the Revolve tool to revolve the entire quadrilateral sketch 360 degrees around the Z axis to create a full flattened cone: Finally, since the warmup asked me for a 2D drawing, I generated a 2D drawing based off the design.","title":"Flattened Cone Warmup"},{"location":"edm2/lessons/fusionpart2/#bicycle-rack-design","text":"As a review and challenge for my current Fusion360 knowledge, I was asked to design a bicycle rack to a set of specified dimensions. Here is the image with dimensions that I was designing off of: I first created a sketch on the ZY-plane and used the line and circle tools to design my sketch to match the specified dimensions: I then created a new sketch on the XY-plane and created a circle with a diameter of 4mm. To make the design 3D, I used the sweep tool to sweep the circle along the path of the bike rack.","title":"Bicycle Rack Design"},{"location":"edm2/lessons/fusionpart2/#generating-2d-drawings","text":"I used Kevin Kennedy's Youtube Video to learn how to generate 2D drawings in Fusion. To make a 2D drawing, I first navigated to the design I wanted to make a drawing of. I then clicked on the File dropdown menu, and clicked New Drawing -> From Design , making sure to select the object I wanted a drawing of. To practice making 2D drawings, I generated a drawing from the Fusion360 example design for a connector joint: I then created a 2D drawing of my bicycle rack design:","title":"Generating 2D Drawings"},{"location":"edm2/lessons/fusionpart2/#lego-technic-brick-design","text":"For more practice designing objects in Fusion, I was asked to create a Lego Technic Brick from the following image to its dimensions: There were many possible approaches to designing the brick, but I started with a 3D rectangular prism to match the general specifications of the actual brick part of the Lego. From there, I created concentric circles on the sides and the top, and extruded them (both as a new body and as a hole function) to the dimensions in the image. To create the Lego connectors at the bottom, I created 3 circles centered at the midpoints between the radii of the circle connectors on the top of the Lego brick. I then shelled the entire rectangular prism to hollow it out. Here is my completed design:","title":"Lego Technic Brick Design"},{"location":"edm2/lessons/fusionpart2/#custom-lego-design","text":"I was then challenged to design a custom lego brick. I started designing the brick from the main Lego body as it was relatively simply and would be a good base to design the appendages from. I then sketched and extruded one appendage, mirroring it to all 4 sides of the Lego brick. Lastly, I touched up the brick, adding things like the Lego plus connector joint and smoothing out issues with the spline curve extrursion. The following image shows the brick that I was assigned to design. I first used digital calipers to measure every dimension of the Lego brick. I would continue to use these calipers as I went through the designing process to ensure my dimensions were correct. I started off with designing the body of the custom brick. I designed a sketch on the XY plane and extruded it to create the main body of the brick: Next, I created a sketch to design one of the four appendages coming out of the Lego brick's body. I then mirrored it to all four positions and extruded them. I then created and extruded a spline curve on the side of the Lego brick to mimic the curve of the real brick. To create the plus axle joint I created another sketch in the shape of the plus, which I then mirrored and extruded. Here was my final recreation of the Lego brick, shown in both 2D and 3D views:","title":"Custom Lego Design"},{"location":"edm2/lessons/fusionpart2/#trading-lego-designs","text":"Next, I traded Lego designs with a partner. We sent each other our respective 2D views of our design with dimensions. I would then model his Lego brick based solely on the 2D design he sent me: I started the design by creating a sketch for the base of the Lego. I then extruded each of the base's parts to the proper length. I extruded the area between the concentric circles and the two outer rectangles as Lego connectors. I then created a sphere above the base, which I subsequently cut in half. Next, I shelled the semisphere to make it hollow. I then created 3 sketches on planes oriented 120 degrees from each other. I created a rectangle perpendicular to each of the three planes. I then used the sweep tool to sweep the rectangle on the path, creating a hole that fits to the spherical shape. Here are the 3D and 2D views of the final design:","title":"Trading Lego Designs"},{"location":"edm2/lessons/fusionpart2/#custom-object-design","text":"To further practice using Fusion, I decided to design a pen holder, of which the tutorial can be found here . My Fusion360 file of the design can be downloaded here . To make the design, I started off with shelling a large cylinder. I then created a polygon on the XZ plane and extruded it as a hole onto the surface of the cylinder. I then repeated this across the whole surface of the cylinder via the rectangular and circular pattern tools. To print this file, I first exported the file out of Fusion360 and opened it in PrusaSlicer. I then sliced the file with grid supports and a 15% infill, scaling the design down to finish printing under an hour. Since I was printing at home, my printer wasn't setup with wifi capabilities, so I saved the sliced file onto a flash drive which I then plugged into the printer. Because the hexagonal patterning was so thin, when I originally printed the design, it was heavily reliant on supports. Those supports obscured the actual design and when I tried to peel them away, the entire design crumbled. To solve this issue, I first upscaled the print which made the mesh more stable. I also changed the support type to be organic instead of grid, which minimized the points of contact between the supports and the actual print. This time, the supports were a lot easier to remove and did not damage the structure","title":"Custom Object Design"},{"location":"edm2/lessons/milling/","text":"Milling About The purpose of this unit was to familiarize ourselves to the entire milling process. We discussed different types of milling machines, and their respective differences and use cases. We first created and milled a simple design on a dog tag to get used to the milling process. Then, we designed a model for a chocolate mold and milled it on a block of wax. Finally, we laser cut a box from cardstock to fit the Valentine's Day theme. Workflow Apply double-sided adhesive to your material and the bed. Position and place the material on the bed. Open Bantam Tools Software Under home, select install tool, and select the bit that you are installing Insert your tool into the spindle Use the 2 wrenches by the milling machine and align them respectively to the top of the spindle area and by the middle bit area where their imprints are Have you or a partner hold the bit itself while you unscrew it. This is to prevent the bit from dropping onto the bed and potentially breaking. To loosen the bit, bring the 2 wrenches in towards each other If using multiple bits, select them all under File Setup. Start with the smallest tool and make your way to the largest. Probe Move the metal prong from the side of the bed to sit on top of it. Make sure that they touch so electricity can conduct. Click Z Only Stick Probing and use the Jog menu to move the spindle above your material. Once the spindle is positioned above your material, start the probing. Under Material Setup, leave the Material Offset Z at 0.01mm Change the Material Size to the dimensions of your material. Import your file under File Setup Choose the bit(s) you will be using You can see the projection of the result on the right side of the screen. Use the Plan Offset x, y, and z setting to move the placement of the design around. Ensure that you have the correct bit selected and inserted into the machine. Run the job from the Summary/Run section. It is recommended to run the engraving job before the cutting job to ensure that your material does not move around. If you are using multiple bits, the machine will pause during the job and prompt you to change bits. Dog Tag Before milling the dog tag, I brainstormed an idea for what the tag would look like. I decided upon a simple design with just my name on the tag. I then created the design in CorelDraw. To do this, I first imported a template of the dogtag. This template functions as effective boundaries for my design to ensure that they can all be milled inside the actual dogtag. I then created a textbox inside the area of the dogtag and type my name into it. The following image image contains both the outline and the text, but when actually milling the file, I deleted the outline and only milled the text, as the outline is just a reference to guage size and there is no need to cut out the outline of the dog tag because it is already an individual material piece. I then sent the file to Bantam Software and milled it on the Bantam Desktop CNC Machine. I first set the dimensions of the material to the size of the dogtag, measured via calipers. Next, I equipped the 1/8\" bit and used Bantam Software's Install Tool function to ensure that the tool was homed and its length was calibrated correctly. I then used the Z Only Stick Probing function to calibrate the height offset of my material. I then ran the job. The main problem I encountered was the machine not milling deep enough to actually engrave the material, as the bit would either only barely touch the dog tag or start engraving in the air altogether. This problem was solved by rebooting both the machine and the software and redoing the tool length calibration and Z Material Offset calibration. Here is the final milled dogtag: Chocolate Mold Before starting to design the mold, I created a quick sketch for my idea of the mold. Each member of our group created an individual design so that we could get different perspectives about the mold's design and aggregate them all into a final design. After discussing with my groupmates, we decided to use the following design for the mold. I then created the design in Fusion360. I first created a cube, then extruded a heart-shaped hole on the top face of the cube. I then converted the design to a toolpath. I changed workspaces from Design to Manufacturing. I then selected 3D Adaptive Clearing and selected the heart hole, then generated the design. I later realized that this actually caused the final design to be inverted, where the heart shaped hole was not cut out and everything else was cut out. If I were to redo the milling process, I would make sure to select the other components of the design as to make sure the heart indentation was being cutout. Unfortunately, I did not realize this mistake at the time and thus the wax mold would be inverted. However, the rest of the milling process is correct. Here is the simulation of the toolpaths. If I had realized to use the simulate function to check the actual milling toolpaths, I may have realized the error before milling. However, nobody in our group realized that the simulation function existed until after we finished milling. The wax mold was milled on a Bantam Tools Desktop CNC Milling Machine, as opposed to the dog tag which was milled on an Othermill Milling Machine. The process for milling was very similar as both machines used the Bantam Tools Desktop Milling Machine Software as a gateway for milling designs (the producers of the Othermill and Bantam machines are the same company). Here is the final mold after milling: Chocolate Box To complement the chocolate mold and the Valentine's Day theme, I also designed and cut a chocolate box on special cardstock that had a gold infill. I designed the box in CorelDraw with tabs so that we could use small bits of double-sided tape to hold the box together while maintaining food safety, and designed a tab on the front to be able to close the box. I put raster lines where two faces met together so that we would be able to fold the box easier after the cut. We then sent the design to the laser cutter. Here is the box after putting the bits of tape on the tabs: For fun, we disassembled the box and engraved a hearts design on the top of the box. Here is the box (closed via the tab) with the hearts design on top. Overall Problems Most of this project went smoothly. The only area in which I encountered some difficulty was milling. At first, when running my dog tag job, the milling machine wouldn't probe correctly and would start cutting in the air, which was solved by restarting the machine and the software and re-running the 1 axis Z probing. When running the wax mold job, the heart symbol was inversed and was left uncut while the rest of the mold was cut. Unfortunately, this issue was not resolved before we cut the wax as we did not realize its presence, but in the future, this issue could be solved by running a simulation of the job before actually cutting.","title":"Milling About"},{"location":"edm2/lessons/milling/#milling-about","text":"The purpose of this unit was to familiarize ourselves to the entire milling process. We discussed different types of milling machines, and their respective differences and use cases. We first created and milled a simple design on a dog tag to get used to the milling process. Then, we designed a model for a chocolate mold and milled it on a block of wax. Finally, we laser cut a box from cardstock to fit the Valentine's Day theme.","title":"Milling About"},{"location":"edm2/lessons/milling/#workflow","text":"Apply double-sided adhesive to your material and the bed. Position and place the material on the bed. Open Bantam Tools Software Under home, select install tool, and select the bit that you are installing Insert your tool into the spindle Use the 2 wrenches by the milling machine and align them respectively to the top of the spindle area and by the middle bit area where their imprints are Have you or a partner hold the bit itself while you unscrew it. This is to prevent the bit from dropping onto the bed and potentially breaking. To loosen the bit, bring the 2 wrenches in towards each other If using multiple bits, select them all under File Setup. Start with the smallest tool and make your way to the largest. Probe Move the metal prong from the side of the bed to sit on top of it. Make sure that they touch so electricity can conduct. Click Z Only Stick Probing and use the Jog menu to move the spindle above your material. Once the spindle is positioned above your material, start the probing. Under Material Setup, leave the Material Offset Z at 0.01mm Change the Material Size to the dimensions of your material. Import your file under File Setup Choose the bit(s) you will be using You can see the projection of the result on the right side of the screen. Use the Plan Offset x, y, and z setting to move the placement of the design around. Ensure that you have the correct bit selected and inserted into the machine. Run the job from the Summary/Run section. It is recommended to run the engraving job before the cutting job to ensure that your material does not move around. If you are using multiple bits, the machine will pause during the job and prompt you to change bits.","title":"Workflow"},{"location":"edm2/lessons/milling/#dog-tag","text":"Before milling the dog tag, I brainstormed an idea for what the tag would look like. I decided upon a simple design with just my name on the tag. I then created the design in CorelDraw. To do this, I first imported a template of the dogtag. This template functions as effective boundaries for my design to ensure that they can all be milled inside the actual dogtag. I then created a textbox inside the area of the dogtag and type my name into it. The following image image contains both the outline and the text, but when actually milling the file, I deleted the outline and only milled the text, as the outline is just a reference to guage size and there is no need to cut out the outline of the dog tag because it is already an individual material piece. I then sent the file to Bantam Software and milled it on the Bantam Desktop CNC Machine. I first set the dimensions of the material to the size of the dogtag, measured via calipers. Next, I equipped the 1/8\" bit and used Bantam Software's Install Tool function to ensure that the tool was homed and its length was calibrated correctly. I then used the Z Only Stick Probing function to calibrate the height offset of my material. I then ran the job. The main problem I encountered was the machine not milling deep enough to actually engrave the material, as the bit would either only barely touch the dog tag or start engraving in the air altogether. This problem was solved by rebooting both the machine and the software and redoing the tool length calibration and Z Material Offset calibration. Here is the final milled dogtag:","title":"Dog Tag"},{"location":"edm2/lessons/milling/#chocolate-mold","text":"Before starting to design the mold, I created a quick sketch for my idea of the mold. Each member of our group created an individual design so that we could get different perspectives about the mold's design and aggregate them all into a final design. After discussing with my groupmates, we decided to use the following design for the mold. I then created the design in Fusion360. I first created a cube, then extruded a heart-shaped hole on the top face of the cube. I then converted the design to a toolpath. I changed workspaces from Design to Manufacturing. I then selected 3D Adaptive Clearing and selected the heart hole, then generated the design. I later realized that this actually caused the final design to be inverted, where the heart shaped hole was not cut out and everything else was cut out. If I were to redo the milling process, I would make sure to select the other components of the design as to make sure the heart indentation was being cutout. Unfortunately, I did not realize this mistake at the time and thus the wax mold would be inverted. However, the rest of the milling process is correct. Here is the simulation of the toolpaths. If I had realized to use the simulate function to check the actual milling toolpaths, I may have realized the error before milling. However, nobody in our group realized that the simulation function existed until after we finished milling. The wax mold was milled on a Bantam Tools Desktop CNC Milling Machine, as opposed to the dog tag which was milled on an Othermill Milling Machine. The process for milling was very similar as both machines used the Bantam Tools Desktop Milling Machine Software as a gateway for milling designs (the producers of the Othermill and Bantam machines are the same company). Here is the final mold after milling:","title":"Chocolate Mold"},{"location":"edm2/lessons/milling/#chocolate-box","text":"To complement the chocolate mold and the Valentine's Day theme, I also designed and cut a chocolate box on special cardstock that had a gold infill. I designed the box in CorelDraw with tabs so that we could use small bits of double-sided tape to hold the box together while maintaining food safety, and designed a tab on the front to be able to close the box. I put raster lines where two faces met together so that we would be able to fold the box easier after the cut. We then sent the design to the laser cutter. Here is the box after putting the bits of tape on the tabs: For fun, we disassembled the box and engraved a hearts design on the top of the box. Here is the box (closed via the tab) with the hearts design on top.","title":"Chocolate Box"},{"location":"edm2/lessons/milling/#overall-problems","text":"Most of this project went smoothly. The only area in which I encountered some difficulty was milling. At first, when running my dog tag job, the milling machine wouldn't probe correctly and would start cutting in the air, which was solved by restarting the machine and the software and re-running the 1 axis Z probing. When running the wax mold job, the heart symbol was inversed and was left uncut while the rest of the mold was cut. Unfortunately, this issue was not resolved before we cut the wax as we did not realize its presence, but in the future, this issue could be solved by running a simulation of the job before actually cutting.","title":"Overall Problems"}]}